<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toon Shader para Personaje</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }
        #info h3 {
            margin: 0 0 10px 0;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3> Toon Shader para Personaje</h3>
        <p>Shader estilo cartoon con contornos negros</p>
        <p>El personaje tendr谩 iluminaci贸n celshading</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Configuraci贸n de la escena
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 1.5, 3);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Shader Toon personalizado para el personaje
        const toonVertexShader = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const toonFragmentShader = `
            uniform vec3 uLightPosition;
            uniform vec3 uColor;
            uniform float uAmbient;
            
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            void main() {
                // Normalizar vectores
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightPosition - vViewPosition);
                
                // C谩lculo de iluminaci贸n
                float diff = max(dot(normal, lightDir), 0.0);
                
                // Celshading (bandas de color)
                float toonDiff;
                if (diff > 0.95) toonDiff = 1.0;
                else if (diff > 0.5) toonDiff = 0.7;
                else if (diff > 0.25) toonDiff = 0.4;
                else toonDiff = 0.2;
                
                // Color final con iluminaci贸n toon
                vec3 ambient = uColor * uAmbient;
                vec3 diffuse = uColor * toonDiff;
                vec3 finalColor = ambient + diffuse;
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // Shader para contornos negros
        const outlineVertexShader = `
            uniform float uOutlineWidth;
            
            void main() {
                vec3 newPosition = position + normal * uOutlineWidth;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `;

        const outlineFragmentShader = `
            uniform vec3 uOutlineColor;
            
            void main() {
                gl_FragColor = vec4(uOutlineColor, 1.0);
            }
        `;

        // Funci贸n para crear material toon para el personaje
        function createToonMaterial(color) {
            return new THREE.ShaderMaterial({
                uniforms: {
                    uLightPosition: { value: new THREE.Vector3(5, 10, 5) },
                    uColor: { value: new THREE.Color(color) },
                    uAmbient: { value: 0.4 }
                },
                vertexShader: toonVertexShader,
                fragmentShader: toonFragmentShader
            });
        }

        // Funci贸n para crear material de contorno
        function createOutlineMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    uOutlineWidth: { value: 0.03 },
                    uOutlineColor: { value: new THREE.Color(0x000000) }
                },
                vertexShader: outlineVertexShader,
                fragmentShader: outlineFragmentShader,
                side: THREE.BackSide
            });
        }

        // Crear personaje ejemplo (similar al de la imagen)
        const character = new THREE.Group();

        // Cuerpo (sudadera naranja)
        const bodyGeometry = new THREE.CylinderGeometry(0.35, 0.4, 0.8, 8);
        const bodyMaterial = createToonMaterial(0xffa500); // Naranja
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.8;
        body.castShadow = true;
        
        // Contorno del cuerpo
        const bodyOutline = new THREE.Mesh(bodyGeometry, createOutlineMaterial());
        bodyOutline.position.copy(body.position);
        
        // Cabeza
        const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const headMaterial = createToonMaterial(0xffd4a3); // Color piel
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 1.5;
        head.castShadow = true;
        
        const headOutline = new THREE.Mesh(headGeometry, createOutlineMaterial());
        headOutline.position.copy(head.position);

        // Piernas
        const legGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 8);
        const legMaterial = createToonMaterial(0x333333); // Negro
        
        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(-0.15, 0.1, 0);
        leftLeg.castShadow = true;
        
        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0.15, 0.1, 0);
        rightLeg.castShadow = true;
        
        const leftLegOutline = new THREE.Mesh(legGeometry, createOutlineMaterial());
        leftLegOutline.position.copy(leftLeg.position);
        
        const rightLegOutline = new THREE.Mesh(legGeometry, createOutlineMaterial());
        rightLegOutline.position.copy(rightLeg.position);

        // Brazos
        const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
        const armMaterial = createToonMaterial(0xffa500);
        
        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.45, 0.9, 0);
        leftArm.rotation.z = Math.PI / 6;
        leftArm.castShadow = true;
        
        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.45, 0.9, 0);
        rightArm.rotation.z = -Math.PI / 6;
        rightArm.castShadow = true;
        
        const leftArmOutline = new THREE.Mesh(armGeometry, createOutlineMaterial());
        leftArmOutline.position.copy(leftArm.position);
        leftArmOutline.rotation.copy(leftArm.rotation);
        
        const rightArmOutline = new THREE.Mesh(armGeometry, createOutlineMaterial());
        rightArmOutline.position.copy(rightArm.position);
        rightArmOutline.rotation.copy(rightArm.rotation);

        // Zapatos
        const shoeGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.25);
        const shoeMaterial = createToonMaterial(0xffa500);
        
        const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
        leftShoe.position.set(-0.15, -0.15, 0.05);
        leftShoe.castShadow = true;
        
        const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
        rightShoe.position.set(0.15, -0.15, 0.05);
        rightShoe.castShadow = true;
        
        const leftShoeOutline = new THREE.Mesh(shoeGeometry, createOutlineMaterial());
        leftShoeOutline.position.copy(leftShoe.position);
        
        const rightShoeOutline = new THREE.Mesh(shoeGeometry, createOutlineMaterial());
        rightShoeOutline.position.copy(rightShoe.position);

        // Agregar todo al grupo del personaje
        character.add(body, bodyOutline);
        character.add(head, headOutline);
        character.add(leftLeg, rightLeg, leftLegOutline, rightLegOutline);
        character.add(leftArm, rightArm, leftArmOutline, rightArmOutline);
        character.add(leftShoe, rightShoe, leftShoeOutline, rightShoeOutline);
        
        scene.add(character);

        // Suelo simple
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x5a8f5a,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Iluminaci贸n direccional (simula el sol)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        scene.add(directionalLight);

        // Luz ambiental suave
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Animaci贸n
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotar el personaje lentamente
            character.rotation.y += 0.005;
            
            renderer.render(scene, camera);
        }

        animate();

        // Responsive
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html