<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C√°mara Estilo Batalla Pok√©mon</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
        }
        button {
            background: #ff0000;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #cc0000;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>üéÆ Controles de C√°mara Pok√©mon</h3>
        <button onclick="changeView('player')">Vista Jugador</button>
        <button onclick="changeView('opponent')">Vista Oponente</button>
        <button onclick="changeView('wide')">Vista Amplia</button>
        <button onclick="changeView('dynamic')">Vista Din√°mica</button>
        <p style="margin-top: 10px; font-size: 12px;">
            WASD: Mover personaje<br>
            Mouse: Rotar vista din√°mica
        </p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuraci√≥n de la escena
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 50, 150);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Iluminaci√≥n
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Arena de batalla (como en Pok√©mon)
        const arenaGeometry = new THREE.CircleGeometry(15, 32);
        const arenaMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b4513,
            roughness: 0.8
        });
        const arena = new THREE.Mesh(arenaGeometry, arenaMaterial);
        arena.rotation.x = -Math.PI / 2;
        arena.receiveShadow = true;
        scene.add(arena);

        // L√≠neas del campo
        const lineGeometry = new THREE.RingGeometry(14, 14.2, 32);
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.rotation.x = -Math.PI / 2;
        line.position.y = 0.01;
        scene.add(line);

        // Crear "Pok√©mon" del jugador (esfera roja)
        const playerGeometry = new THREE.SphereGeometry(1, 32, 32);
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(-2, 1, 6);
        player.castShadow = true;
        scene.add(player);

        // Crear entrenador del jugador
        const playerTrainer = createTrainer(0xff6b6b);
        playerTrainer.position.set(-4, 0, 9);
        scene.add(playerTrainer);

        // Crear "Pok√©mon" oponente (esfera azul)
        const opponentGeometry = new THREE.SphereGeometry(1.2, 32, 32);
        const opponentMaterial = new THREE.MeshStandardMaterial({ color: 0x3333ff });
        const opponent = new THREE.Mesh(opponentGeometry, opponentMaterial);
        opponent.position.set(2, 1.2, -6);
        opponent.castShadow = true;
        scene.add(opponent);

        // Crear entrenador oponente
        const opponentTrainer = createTrainer(0x6b6bff);
        opponentTrainer.position.set(4, 0, -9);
        scene.add(opponentTrainer);

        // Funci√≥n para crear un entrenador simplificado
        function createTrainer(color) {
            const trainer = new THREE.Group();

            // Cuerpo (usando BoxGeometry)
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.2;
            body.castShadow = true;
            trainer.add(body);

            // Cabeza
            const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.2;
            head.castShadow = true;
            trainer.add(head);

            // Brazos (usando CylinderGeometry)
            const armGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ color: color });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 1.3, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            trainer.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 1.3, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            trainer.add(rightArm);

            // Piernas (usando CylinderGeometry)
            const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.9, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, 0.5, 0);
            leftLeg.castShadow = true;
            trainer.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, 0.5, 0);
            rightLeg.castShadow = true;
            trainer.add(rightLeg);

            return trainer;
        }

        // Plataformas
        const platformGeometry = new THREE.CylinderGeometry(2, 2, 0.5, 32);
        const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
        
        const playerPlatform = new THREE.Mesh(platformGeometry, platformMaterial);
        playerPlatform.position.set(-2, 0.25, 6);
        playerPlatform.castShadow = true;
        scene.add(playerPlatform);

        const opponentPlatform = new THREE.Mesh(platformGeometry, platformMaterial);
        opponentPlatform.position.set(2, 0.25, -6);
        opponentPlatform.castShadow = true;
        scene.add(opponentPlatform);

        // Variables de c√°mara
        let cameraMode = 'player';
        let targetPosition = new THREE.Vector3();
        let targetLookAt = new THREE.Vector3();
        let mouseX = 0;
        let mouseY = 0;

        // Controles de movimiento
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        });

        // Funci√≥n para cambiar vista
        function changeView(mode) {
            cameraMode = mode;
        }
        window.changeView = changeView;

        // Actualizar posici√≥n de la c√°mara seg√∫n el modo
        function updateCamera() {
            const smoothing = 0.05;

            switch(cameraMode) {
                case 'player':
                    // Vista desde detr√°s del entrenador jugador (t√≠pica de Pok√©mon)
                    targetPosition.set(
                        playerTrainer.position.x - 2,
                        playerTrainer.position.y + 4,
                        playerTrainer.position.z + 6
                    );
                    targetLookAt.set(
                        opponent.position.x,
                        opponent.position.y,
                        opponent.position.z
                    );
                    break;

                case 'opponent':
                    // Vista desde detr√°s del entrenador oponente
                    targetPosition.set(
                        opponentTrainer.position.x + 2,
                        opponentTrainer.position.y + 4,
                        opponentTrainer.position.z - 6
                    );
                    targetLookAt.set(
                        player.position.x,
                        player.position.y,
                        player.position.z
                    );
                    break;

                case 'wide':
                    // Vista amplia lateral
                    targetPosition.set(18, 8, 0);
                    targetLookAt.set(0, 1, 0);
                    break;

                case 'dynamic':
                    // Vista din√°mica controlada por mouse
                    const radius = 15;
                    const angle = mouseX * Math.PI;
                    const height = 5 + mouseY * 5;
                    targetPosition.set(
                        Math.sin(angle) * radius,
                        height,
                        Math.cos(angle) * radius
                    );
                    targetLookAt.set(0, 1, 0);
                    break;
            }

            // Suavizar movimiento de c√°mara
            camera.position.lerp(targetPosition, smoothing);
            
            const lookAtCurrent = new THREE.Vector3();
            camera.getWorldDirection(lookAtCurrent);
            lookAtCurrent.multiplyScalar(10).add(camera.position);
            lookAtCurrent.lerp(targetLookAt, smoothing);
            camera.lookAt(lookAtCurrent);
        }

        // Mover jugador y su Pok√©mon
        function movePlayer() {
            const speed = 0.1;
            if (keys['w']) {
                player.position.z -= speed;
                playerTrainer.position.z -= speed;
            }
            if (keys['s']) {
                player.position.z += speed;
                playerTrainer.position.z += speed;
            }
            if (keys['a']) {
                player.position.x -= speed;
                playerTrainer.position.x -= speed;
            }
            if (keys['d']) {
                player.position.x += speed;
                playerTrainer.position.x += speed;
            }

            // Limitar al √°rea de la arena
            const maxDist = 12;
            player.position.x = Math.max(-maxDist, Math.min(maxDist, player.position.x));
            player.position.z = Math.max(-maxDist, Math.min(maxDist, player.position.z));
            playerTrainer.position.x = Math.max(-maxDist, Math.min(maxDist, playerTrainer.position.x));
            playerTrainer.position.z = Math.max(-maxDist, Math.min(maxDist, playerTrainer.position.z));

            // Mantener al entrenador detr√°s del Pok√©mon
            const offset = 3;
            playerTrainer.position.x = player.position.x - 2;
            playerTrainer.position.z = player.position.z + offset;
        }

        // Animaci√≥n del oponente
        let time = 0;
        function animateOpponent() {
            time += 0.02;
            opponent.position.y = 1.2 + Math.sin(time * 2) * 0.2;
            opponent.rotation.y += 0.01;
        }

        // Animaci√≥n del jugador
        function animatePlayer() {
            player.rotation.y += 0.02;
        }

        // Loop de animaci√≥n
        function animate() {
            requestAnimationFrame(animate);

            movePlayer();
            animatePlayer();
            animateOpponent();
            updateCamera();

            renderer.render(scene, camera);
        }

        // Responsive
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Inicializar c√°mara
        camera.position.set(0, 5, 15);
        camera.lookAt(0, 1, 0);

        animate();
    </script>
</body>
</html>